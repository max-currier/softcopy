####################
# NECESSARY IMPORTS#
####################

# core app function mechanics
import pandas as pd
import numpy as np
import cv2
from PIL import Image
import pickle

# importing custom functions
from softcopyOCR import decode_predictions, get_image_text, clean_string, clean_tesseract_output, display_ocr
from softcopy_textmatch import best_match
from softcopy_recommender import get_recommends_list, get_recommends, get_book_details

# app building
import streamlit as st
import time
import urllib.request
import io

# surpress streamlit warning
st.set_option('deprecation.showfileUploaderEncoding', False)
st.beta_set_page_config(page_title='SOFTCOPY',
                        page_icon=None,
                        layout='centered',
                        initial_sidebar_state='auto')

# loading data
with open('data/all_books_clean.pkl', 'rb') as f:
    books_all = pickle.load(f)

ISBNs = pd.read_csv('data/ISBNs.csv')

with open('data/vt_800.pkl', 'rb') as f:
    VT = pickle.load(f)


def show_book_images(recs):
    '''
    Displays images of recommendation ocr_results
    recs: list, ISBNs, of book recommendations
    '''
    # iterate through book recommendations
    for book in recs:
        try:
            # get url of large image for each recommended book
            rec_dict = get_book_details(book, books_all)
            url = rec_dict['image_l']
            with urllib.request.urlopen(url) as url:
                with open('temp.jpg', 'wb') as f:
                    f.write(url.read())

            # load and display image
            test_img = Image.open('temp.jpg')
            st.image(test_img)

        # error handling for image display error (rare)
        except OSError:
            pass

    # done!
    st.balloons()


def get_recs(matched_isbns, num_recs):
    '''
    Gets recommendations from matched ISBN_list
    Returns list of ISBNs for recommended books based on books in matched_isbns
    matched_isbns: list, book ISBNs matched from ORC output, produced by match_title
    '''

    st.header('**Step 3: Recommend books based on the ones on your bookshelf**')
    st.markdown('Getting recommendations...')

    # animates quick loading bar
    rec_loading_bar = st.progress(0)
    for percent_complete in range(100):
        time.sleep(0.02)
        rec_loading_bar.progress(percent_complete + 1)

    # gets recommendations
    global VT, ISBNs, books_all
    recs, basis = get_recommends_list(matched_isbns, VT, ISBNs, n=num_recs)

    # prints recommendation basis
    st.subheader('Based off of these books that you own : ')
    for book in basis:
        rec_dict = get_book_details(book, books_all)
        st.markdown("* {} by {} ({}, {})".format(rec_dict['title'],
                                                rec_dict['author'],
                                                rec_dict['publisher'],
                                                rec_dict['year']))

    # prints recommendations
    st.subheader('Your recommended reading includes: ')
    for book in recs:
        rec_dict = get_book_details(book, books_all)
        st.markdown("* {} by {} ({}, {})".format(rec_dict['title'],
                                                rec_dict['author'],
                                                rec_dict['publisher'],
                                                rec_dict['year']))

    # passing recs on to book cover displaying function
    show_book_images(recs)


def match_title(final_ocr, num_recs, confidence):
    '''
    Matches OCR text with book ISBNs
    Returns list of ISBNs of books that match OCR text above the confidence threshold
    final_ocr: list, strings for each grouping of text generated by OCR process
    '''

    st.header('**Step 2: Match OCR results to books in our database**')
    st.write("Matching titles...")
    match_loading_bar = st.progress(0)
    st.subheader('Text matching results:')

    matched_isbns = []
    global books_all

    # finding best match for each string detected by OCR
    for idx, title in enumerate(final_ocr):
        match_loading_bar.progress((idx+1)/len(final_ocr)) # increments loading bar
        match = best_match(title, books_all, min_confidence=confidence)
        matched_isbns.append(match)

    # w.i.p.: buttons to deselect books from rec process
    buttons = [get_book_details(i, books_all)['title'] for i in matched_isbns if get_book_details(i, books_all)]
    match_select = st.sidebar.multiselect('Recommendation basis: ', buttons, buttons)

    # passing matched titles on to recommendation engine
    get_recs(matched_isbns, num_recs)


def run_ocr(new_img, num_recs, confidence, verbose):
    '''
    Performs optical character recognition on specified image
    Returns list of strings
    new_img: image, supplied by main
    '''

    # parameters for OpenVC
    args = {'east': 'frozen_east_text_detection.pb',
            'min_confidence': 0.9,
            'width': 320,
            'height': 320,
            'padding': 0.2}

    st.header('**Step 1: Scan your image for text with OCR**')
    st.write('Scanning image...')

    # images preprocessing, text detection w/ open cv, and text recognition
    # with pytesseract
    ocr_results = get_image_text(args, new_img)

    # show boundary boxes during scan if sidebar box checked
    if verbose:
        display_ocr(ocr_results, new_img)

    # cleans up strings
    final_ocr = clean_tesseract_output(ocr_results, 100)

    # prints results
    st.subheader("Optical character recognition results: ")
    st.write(pd.DataFrame(final_ocr, columns = ['']))

    # passes final ocr results to text matching
    match_title(final_ocr, num_recs, confidence)


def main():
    '''
    Main app function. Features page selector and image upload.
    Press button once image uploaded to start matching/recommendation pipeline
    '''
    st.title('SoftCopy')
    activities = ['Home', 'About']

    # main site nav
    choice = st.sidebar.selectbox("", activities)

    st.sidebar.write('App parameters')

    # recs/text match for get_recs / get_recommends_list fcns
    num_recs = st.sidebar.slider("Recommendations per match", 1, 10, 4) #

    # text match confidence threshold for match_title / best_match fcns
    confidence = st.sidebar.slider('Text matching confidence % threshold',
    0, 100, 75)

    # toggle to show text detection/recognition images during OCR
    verbose = st.sidebar.checkbox('Show OCR Preprocessing', value=False)

    # main site nav choice
    if choice == 'Home':

        # image uploader
        st.header('**Upload an image of your books.**')
        st.header('**Get customized book recommendations.**')

        uploaded_file = st.file_uploader("Choose a image file")

        # displaying uploaded image
        if uploaded_file is not None:
            image_ = Image.open(uploaded_file) # reads image file
            st.image(image_, caption='Uploaded image', use_column_width=True) # displays on app
            new_img = np.array(image_.convert('RGB')) # makes it compatible with OpenCV

            # click to run program (pass image on to OCR)
            if st.button("Let's get started!"):
                run_ocr(new_img, num_recs, confidence, verbose)

    # main site nav choice
    elif choice == 'About':
        about()


def about():
    '''
    Helper function for the about page
    '''
    # overview
    st.subheader('About SoftCopy')
    st.markdown(
                '''
                SoftCopy uses an image of your bookshelf to recommend books for you to read.
                All you need to do is import a photo and the app does the rest!

                The app has three main phases:

                1. Optical character recognition (OCR)
                2. Text matching
                3. Recommendation
    	''')

    # select which phase to view details
    about_options = st.select_slider(
        label='Select a phase to learn more about how it works',
        options=['OCR', 'Text Matching', 'Recommendation'], )

    # OCR phase details
    if about_options == 'OCR':

        st.subheader('Optical character recognition')

        st.markdown('''SoftCopy uses Python, OpenCV and Pytesseract to detect and recognize text in your image.
        OpenCV is used to process images to prepare them for OCR''')

        st.image("https://nanonets.com/blog/content/images/2019/12/Tesseract.gif", width=500)

        st.markdown('''
        Step 1) Preprocessing
        * Image scaling, red/blue swap (for Pytesseract compatability)
        * Mean image subtraction (for clearer signal)

        Step 2) Text detection
        * Bounding box detection using EAST text detection model
        * Non-maxima suppression to eliminate weak, overlapping bounding boxes

        Step 3) Text recognition
        * Pytesseract - pretrained LSTM Neural Network model
        ''')

        # OCR example image
        st.image('Text detection pics/Text Detection_screenshot_09.09.2020 - 2.png', width=500, caption='OCR in action!')

    # text matching phase details
    if about_options == 'Text Matching':

        st.subheader('Text matching')

        st.markdown('''
        Next, SoftCopy takes the text that was detected during the OCR step and performs
        a **token set fuzzy match** the title and author against a list of **266,664 books**
        pulled from the [Book Crossing dataset](http://www2.informatik.uni-freiburg.de/~cziegler/BX/).
        ''')

        # books crossing logo
        st.image('images/bookcrossing.jpg')

        st.markdown('''
        Matching process:

        1. Combine title and author strings

        2. Tokenize into list of unigrams

        3. Sort tokens alphabetically

        4. Remove duplicate tokens

        5. Compare too each book in data set and assigne confidence scores

        Pairs with over 75% confidence are considered a match, but you can toggle
        this percentage in the sidebar to suit the needs of your image.

        Examples:
        * No match for "sil lack a sian sos oo tian m e a r ii lom aimles ba al".
        (Closest match was "smile like a plastic daisy sonia levitin" with 56% confidence.)

        * Closest match for "my ea t diaz junot d":
        **Drown** by **Junot Diaz** with 77% confidence.''')

        # publication year distribution viz
        st.image('viz/pub_year_dist.png')

        st.markdown('''It is important to note that book in this dataset were mostly published between 1980-2000,
        so the likelihood of matching goes up significantly for books from this time period.''')

    # recommendation phase details
    if about_options == 'Recommendation':

        st.subheader('Getting recommendations')

        st.markdown('''SoftCopy uses **collaborative filtering** to recommend books
        based off how your selections compare to other users book preferences.
        SoftCopy's recommendation matrix
        is comprised of:''')

        st.markdown('''
        * 134,299 ratings

        * 10,077 books

        * 12,854 unique reviewers
        ''')

        st.image(['viz/user_age_dist.png', 'viz/rating_dist.png'], width=325)

        st.markdown('''Under the hood, SoftCopy uses **singular value decomposition (SVD)**
        to generate 800 abstract features for each book in the Book Crossing data
        based off of how they have been rated by various users. This effectively groups
        the books into categories that can be throught of as something like *genres*.
        ''')

        st.markdown('Illustration of how SVD works:')

        st.image('images/svd.png', width=500)

        st.markdown('''
        The recommendation engine then uses these 800 properties to **compare the cosine similarity** each of your
        books to each book in the database and rank them in order of highest similarity.


        This process does not use any content-level data about your book such as language,
        length, or author to make a recommendation. **Your recommendations are strictly
        generated by collaborative filtering based on user ratings and SVD features!**
        ''')


# starts app
if __name__ == "__main__":
    main()
